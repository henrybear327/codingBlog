---
title: UVa 10369
categories:
  - Competitive Programming
  - UVa
tags:
  - UVa
  - MST
  - Kruskal algorithm
date: 2016-08-17 00:10:00
---


# [Arctic Network](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=24&problem=1310&mosmsg=Submission+received+with+ID+17849405)

## Solution Sketch

Build a MST using Kruskal algorithm.

The curcial observation to solving this problem is $s$ satellites can save you $s - 1$ edges in the MST!

<!-- more -->

So, while you are using Kruskal algorithm to build the MST, you also need to keep a counter of how many edges have been added into the MST. If $p - 1 - cnt = s - 1$, which means total edges in MST $p - 1$, minus $cnt$ (number of edges in MST currently), equals to the edges that can be saved $s - 1$, we can terminate the MST algorithm and output the distance of the last edge that was added.

## AC Code

```c++
#include <bits/stdc++.h>

using namespace std;

typedef pair<int, int> ii;

double dist(ii a, ii b)
{
    int dx = a.first - b.first;
    int dy = a.second - b.second;
    return sqrt(double(dx * dx + dy * dy));
}

#define N 555
struct UFDS {
    int par[N];
    void init()
    {
        memset(par, -1, sizeof(par));
    }

    int root(int x)
    {
        return par[x] < 0 ? x : par[x] = root(par[x]);
    }

    void merge(int x, int y)
    {
        x = root(x);
        y = root(y);

        if (x == y)
            return;

        if (par[x] > par[y])
            swap(x, y);
        par[x] += par[y];
        par[y] = x;
    }
} ufds;

int main()
{
    int ncase;
    scanf("%d", &ncase);

    while (ncase--) {
        int s, p;
        scanf("%d %d", &s, &p);

        vector<ii> inp;
        for (int i = 0; i < p; i++) {
            ii tmp;
            scanf("%d %d", &tmp.first, &tmp.second);

            inp.push_back(tmp);
        }

        // get distance
        vector<pair<double, ii>> pt;
        for (int i = 0; i < (int)inp.size(); i++)
            for (int j = i + 1; j < (int)inp.size(); j++)
                pt.push_back(make_pair(dist(inp[i], inp[j]), ii(i, j)));
        sort(pt.begin(), pt.end());

        // get MST
        ufds.init();
        vector<pair<double, ii>> ans;
        double res = 0;
        int cnt = 0;
        for (int i = 0; i < (int)pt.size(); i++) {
            int u = pt[i].second.first;
            int v = pt[i].second.second;
            double w = pt[i].first;
            if (ufds.root(u) == ufds.root(v))
                continue;

            ufds.merge(u, v);
            res = w;

            cnt++;
            if (p - 1 - cnt == s - 1)
                break;
        }
        printf("%.2f\n", res);
    }

    return 0;
}
```
