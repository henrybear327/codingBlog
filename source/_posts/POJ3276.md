---
title: POJ3276
categories:
  - Competitive Programming
  - POJ
date: 2017-05-19 16:59:54
tags:
  - POJ
  - DP
  - Flip
---

# [Face The Right Way](http://poj.org/problem?id=3276)

## Solution sketch

對於所有的 $K$ 進行 枚舉 和 模擬反轉操作 的話，會是 $O(n^3)$ 所以會 TLE。

其實，一個點反轉兩次等於沒反轉。因此一個點有無被反轉，只需要看他前 $k - 1$ 的區間內反轉次數是奇數還數偶數就好。

因此，我們只要維護區間反轉次數，就可以壓到 $O(n^2)$ 了！

<!-- more -->

## AC code

```c++
#include <algorithm>
#include <cstdio>

using namespace std;

int n;
int inp[5555];
int check(int k)
{
    bool hasChange[5555] = {false};
    int flipCnt = 0;
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (i - k >= 0)
            if (hasChange[i - k] == true)
                cnt--;

        if ((inp[i] + cnt) % 2 == 0)
            continue;

        if (i + k > n)
            return 0x3f3f3f3f;
        flipCnt++;
        hasChange[i] = true;
        cnt++;
    }

    return flipCnt;
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        char tmp[10];
        scanf("%s", tmp);

        if (tmp[0] == 'F')
            inp[i] = 0;
        else
            inp[i] = 1;
    }

    int mn = 0x3f3f3f3f;
    int idx = 1;
    for (int i = 1; i <= n; i++) {
        int cnt = check(i);

        if (cnt < mn) {
            mn = cnt;
            idx = i;
        }
    }
    printf("%d %d\n", idx, mn);

    return 0;
}

```
